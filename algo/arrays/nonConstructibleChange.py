
def nonConstructibleChange(coins):
    if len(coins) == 0:
        return 1

    minimum = 0
    sortedCoins = sorted(coins)
    for coin in sortedCoins:
        if coin > minimum + 1:
            break
        minimum += coin

    return minimum + 1

print(nonConstructibleChange([1, 1, 2, 6]))
# output: 5
print(nonConstructibleChange([5, 7, 1, 1, 2, 3, 22]))
# output: 20

# 解题原理：
# 如果遍历过的所有硬币累加都够不上下一个硬币的面值，那么小于下一个硬币的面值的金额就无法作为零钱找出去。
# 在示例中前几个加起来总数为19，那么22 21 20就都找不出去，即最小不可找零金额为20。
# 这里面想不通的：如何确保18能够找出去？
# 19之前的一个加和是12，怎么知道13 14 15 16 17 18能够找出去？
# [1, 1, 2, 3, 5, 7]
# 累加过程如下：
# 1 + 1 = 2
# 1 + 1 + 2 = 4
# 1 + 1 + 2 + 3 = 7
# 1 + 1 + 2 + 3 + 5 = 12
# 1 + 1 + 2 + 3 + 5 + 7 = 19

#
# 往回看一下，累加到4的时候[1,1,2]，我们知道1 2 3(2+1) 4都能找出去。
# 解1：因为[1,1,2]中4是总数，3=2+1

# 此时我们来做一些假设,假设下一个硬币的面值
# 那么下一个假设是1，+1=5，那么1 2 3 4 5都能找出去。
# 解2：5就是全部; 4是上一次的加和，已经确定能找出去。

# 那么下一个假设是2，+2=6，那么1 2 3 4 5 6都能找出去。
# 解3：6就是全部; 4是上一次的加和，所以也一定能找出去; 那么5能找出去吗？1 1 2 2 从实际看是能5=2+2+1, 但为什么呢？因为5=2+3，2是本次的硬币，3是之前已经被证明可以组合出来的数字,见解1

# 下一个假设是3，+3=7
# 解4: 7就是全部；6=3+3，本次的3和之前被验证过的3，见解1；5=3+2；4=3+1;

# 下一个假设是4，+4=8
# 解5: 8就是全部，7=4+3；6=4+2；5=4+1; 4=3+1;

# 下一个假设是5，+5=9
# 解6: 9就是全部，8=5+3；7=5+2；6=5+1; 5=3+2; 4=3+1

# 下一个假设是6，+6=10
# 解7: 10是全部，9=6+3；8=6+2; 7=6+1; 6=6; 5=6+?；此时我们发现5不可能被找出去了，因为我们使用[1,1,2,6]凑不出5

# 通过上述例子我们可以看到下一个硬币的面值如果超过之前所有硬币的加和的一定范围，就出现了「不连续组合」即所有硬币无法组成连续的数字，那么断掉的第一个数字就是我们无法找零的最小硬币。
# 即如果累加一个硬币的面值之后的值 > 之前所有硬币的累加值，此时之前所有硬币的累加值的下一个数字即为无法找零的最小硬币面值

# 总结：这道题的背后是贪心算法的思想，即每次迭代都依赖之前迭代的结果作为保证，因为之前迭代过的结果一定是经过验证可行的，所以本次迭代只基于之前的结果进行本次迭代的计算进行判断，不对之前的组合进行验证。